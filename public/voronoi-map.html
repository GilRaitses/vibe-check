<!DOCTYPE html>
<html>
<head>
    <title>NYC Voronoi Tessellation - Vibecheck</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f0f2f5; }
        #map { height: 100vh; }
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="info-panel" class="info-panel">
        <h3 id="zone-title">Zone Information</h3>
        <div id="zone-details"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        const map = L.map('map').setView([40.7128, -74.0060], 11); // Centered on NYC

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        }).addTo(map);

        let voronoiLayer = L.svg().addTo(map);

        async function fetchCameraData() {
            try {
                const response = await fetch('/data/nyc-cameras-full.json');
                const cameras = await response.json();
                const points = cameras.filter(c => c.latitude && c.longitude);
                console.log(`Loaded ${points.length} cameras with coordinates.`);
                drawVoronoi(points);
            } catch (error) {
                console.error('Failed to load camera data:', error);
            }
        }

        function drawVoronoi(points) {
            // Remove any previous layer
            if (window.voronoiGeoJsonLayer) {
                map.removeLayer(window.voronoiGeoJsonLayer);
            }

            // Convert camera lat/lng to pixel coords in current map projection
            const pixelPoints = points.map(p => {
                const pt = map.latLngToLayerPoint([p.latitude, p.longitude]);
                return [pt.x, pt.y];
            });

            // Build Delaunay & Voronoi using current map pixel bounds
            const delaunay = d3.Delaunay.from(pixelPoints);
            const bounds = map.getPixelBounds();
            const voronoi = delaunay.voronoi([bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y]);

            const polygons = points.map((d, i) => {
                const cell = voronoi.cellPolygon(i);
                if (!cell) return null;

                const coords = cell.map(([x, y]) => {
                    const latLng = map.layerPointToLatLng(L.point(x, y));
                    return [latLng.lng, latLng.lat];
                });

                // Ensure polygon is closed
                if (coords.length && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {
                    coords.push(coords[0]);
                }

                return {
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [coords]
                    },
                    properties: d
                };
            }).filter(Boolean);

            // Add polygons to map
            window.voronoiGeoJsonLayer = L.geoJSON(polygons, {
                pane: 'overlayPane',
                style: function () {
                    return {
                        color: '#9E9E9E',
                        weight: 0.8,
                        fillColor: '#42a5f5',
                        fillOpacity: 0.15
                    };
                },
                onEachFeature: function (feature, layer) {
                    layer.on({
                        mouseover: function (e) {
                            e.target.setStyle({ fillColor: '#ff6b6b', fillOpacity: 0.45 });
                        },
                        mouseout: function (e) {
                            window.voronoiGeoJsonLayer.resetStyle(e.target);
                        },
                        click: function () {
                            showInfoPanel(feature.properties);
                        }
                    });
                }
            }).addTo(map);

            // (Re)register a single handler to update polygons on map view changes
            if (!window._voronoiListenerAttached) {
                map.on('zoomend moveend', () => drawVoronoi(points));
                window._voronoiListenerAttached = true;
            }
        }
        
        function updateVoronoi(points) {
            drawVoronoi(points);
        }

        function showInfoPanel(props) {
            const infoPanel = document.getElementById('info-panel');
            document.getElementById('zone-title').textContent = props.name || props.camera_name || 'Camera Zone';
            document.getElementById('zone-details').innerHTML = `
                <p><strong>Zone ID:</strong> ${props.zone_id || props.handle || 'N/A'}</p>
                <p><strong>Borough:</strong> ${props.borough || props.area || 'NYC'}</p>
                <p><strong>Status:</strong> ${(props.isOnline === 'true' || props.isOnline === true) ? 'Online' : 'Offline'}</p>
            `;
            infoPanel.style.display = 'block';
        }
        
        map.on('click', () => {
            document.getElementById('info-panel').style.display = 'none';
        });

        fetchCameraData();
    </script>
</body>
</html> 